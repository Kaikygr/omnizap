<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/logs/logger.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/logs/logger.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>require('dotenv').config();
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const { cleanEnv, str } = require('envalid');
const util = require('util');
const fs = require('fs');
const path = require('path');

/**
 * @constant {Object&lt;string, number>} LOG_LEVELS
 * @description Mapeamento dos níveis de log para seus valores numéricos correspondentes.
 * Utilizado pelo Winston para definir a prioridade dos logs.
 * Níveis mais baixos indicam maior prioridade (ex: 'error' é mais prioritário que 'debug').
 */

const LOG_LEVELS = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  verbose: 4,
  debug: 5,
  silly: 6,
};
/**
 * @constant {string[]} LOG_LEVEL_NAMES
 * @description Array contendo os nomes dos níveis de log disponíveis.
 * Derivado das chaves do objeto `LOG_LEVELS`.
 * Utilizado para validação da variável de ambiente `LOG_LEVEL`.
 */
const LOG_LEVEL_NAMES = Object.keys(LOG_LEVELS);

/**
 * @constant {object} env
 * @description Objeto contendo as variáveis de ambiente validadas e processadas pelo `envalid`.
 * Este objeto fornece acesso seguro e tipado às configurações do ambiente.
 * @property {string} NODE_ENV - O ambiente atual da aplicação (development, production, test).
 * @property {string} LOG_LEVEL - O nível de log configurado para a aplicação.
 * @property {string} ECOSYSTEM_NAME - Nome do serviço ou aplicação, usado para identificar a origem dos logs.
 */
const env = cleanEnv(process.env, {
  NODE_ENV: str({
    choices: ['development', 'production', 'test'],
    default: 'development',
    desc: 'Node environment',
  }),
  LOG_LEVEL: str({
    choices: LOG_LEVEL_NAMES,
    default: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
    desc: 'Logging level',
  }),
  ECOSYSTEM_NAME: str({
    default: 'system',
    desc: 'Service or application name for logs',
  }),
});

/**
 * @constant {boolean} IS_PRODUCTION
 * @description Indica se o ambiente atual é de produção.
 * É `true` se `env.NODE_ENV` for 'production', caso contrário `false`.
 * Utilizado para lógicas condicionais baseadas no ambiente.
 */
const IS_PRODUCTION = env.NODE_ENV === 'production';

/**
 * @constant {string} DEFAULT_LOG_LEVEL
 * @description Nível de log padrão para a aplicação, determinado pela configuração de ambiente.
 * Obtido diretamente de `env.LOG_LEVEL` após validação.
 * Este valor é usado como o nível de log para novas instâncias de logger, a menos que seja sobrescrito.
 */
const DEFAULT_LOG_LEVEL = env.LOG_LEVEL;

/**
 * @constant {string} INSTANCE_ID
 * @description Identificador único para a instância da aplicação, utilizado para diferenciar logs
 * em ambientes com múltiplas instâncias rodando simultaneamente (ex: em um cluster ou PM2).
 * Deriva de `env.ECOSYSTEM_NAME`. Se `env.ECOSYSTEM_NAME` for 'system' (o padrão),
 * `INSTANCE_ID` será 'local', indicando uma execução local ou não clusterizada.
 * Caso contrário, `INSTANCE_ID` assume o valor de `env.ECOSYSTEM_NAME`.
 * Este ID é incluído automaticamente nos metadados padrão de cada mensagem de log.
 */
const INSTANCE_ID = env.ECOSYSTEM_NAME !== 'system' ? env.ECOSYSTEM_NAME : 'local';

/**
 * @constant {string} ECOSYSTEM_NAME
 * @description Nome do serviço ou ecossistema ao qual a aplicação pertence, conforme definido
 * pela variável de ambiente `ECOSYSTEM_NAME`.
 * Este nome é usado para categorizar logs e é incluído nos metadados padrão de cada log,
 * facilitando a filtragem e análise de logs em sistemas centralizados.
 */
const ECOSYSTEM_NAME = env.ECOSYSTEM_NAME;

/**
 * @constant {string} NODE_ENV
 * @description Ambiente de execução atual da aplicação (ex: 'development', 'production', 'test').
 * Obtido diretamente de `env.NODE_ENV` após validação.
 * Este valor influencia o comportamento do logger (ex: nível de log padrão, formatação)
 * e é incluído nos metadados padrão de cada log.
 */
const NODE_ENV = env.NODE_ENV;
/**
 * @constant {string} PROJECT_ROOT
 * @description Caminho absoluto para o diretório raiz do projeto.
 * Determinado resolvendo o caminho a partir do diretório do arquivo atual (`__dirname`),
 * subindo três níveis na estrutura de diretórios (`../../../`).
 * Utilizado como base para construir outros caminhos, como o diretório de logs.
 */
const PROJECT_ROOT = path.resolve(__dirname, '..', '..', '..');
/**
 * @constant {string} LOG_DIR_PATH
 * @description Caminho absoluto para o diretório onde os arquivos de log serão armazenados.
 * Formado pela junção de `PROJECT_ROOT` com o subdiretório 'logs'.
 * Este é o diretório que a função `ensureLogDirectoryExists` tentará criar se não existir.
 */
const LOG_DIR_PATH = path.join(PROJECT_ROOT, 'logs');

/**
 * @constant {Object} LOG_DEFAULTS
 * @description Define as configurações padrão para os arquivos de log.
 * Estas configurações são usadas ao criar os transportes de arquivo do Winston,
 * a menos que sejam sobrescritas.
 * @property {string} LOG_DIR - Caminho absoluto para o diretório onde os arquivos de log serão armazenados.
 * @property {string} APP_LOG_FILENAME - Padrão de nome para os arquivos de log da aplicação. Inclui `%DATE%` para rotação diária.
 * @property {string} ERROR_LOG_FILENAME - Padrão de nome para os arquivos de log de erros. Inclui `%DATE%`.
 * @property {string} WARN_LOG_FILENAME - Padrão de nome para os arquivos de log de avisos. Inclui `%DATE%`.
 * @property {string} DATE_PATTERN - Padrão de data usado para a rotação dos arquivos de log (ex: 'YYYY-MM-DD').
 * @property {boolean} ZIPPED_ARCHIVE - Define se os arquivos de log arquivados devem ser compactados (gzip).
 * @property {string} MAX_SIZE_APP - Tamanho máximo para os arquivos de log da aplicação antes da rotação (ex: '20m' para 20MB).
 * @property {string} MAX_FILES_APP - Número máximo de dias para manter os arquivos de log da aplicação (ex: '14d' para 14 dias).
 * @property {string} MAX_SIZE_ERROR - Tamanho máximo para os arquivos de log de erros.
 * @property {string} MAX_FILES_ERROR - Número máximo de dias para manter os arquivos de log de erros.
 * @property {string} MAX_SIZE_WARN - Tamanho máximo para os arquivos de log de avisos.
 * @property {string} MAX_FILES_WARN - Número máximo de dias para manter os arquivos de log de avisos.
 * @property {number} FILE_PERMISSIONS - Permissões (em octal) para os arquivos de log criados.
 * @property {number} DIR_PERMISSIONS - Permissões (em octal) para o diretório de log, se for criado.
 */
const LOG_DEFAULTS = {
  LOG_DIR: LOG_DIR_PATH,
  APP_LOG_FILENAME: 'application-%DATE%.log',
  ERROR_LOG_FILENAME: 'error-%DATE%.log',
  WARN_LOG_FILENAME: 'warn-%DATE%.log',
  DATE_PATTERN: 'YYYY-MM-DD',
  ZIPPED_ARCHIVE: true,
  MAX_SIZE_APP: '20m',
  MAX_FILES_APP: '14d',
  MAX_SIZE_ERROR: '10m',
  MAX_FILES_ERROR: '30d',
  MAX_SIZE_WARN: '10m',
  MAX_FILES_WARN: '14d',
  FILE_PERMISSIONS: 0o777,
  DIR_PERMISSIONS: 0o777,
};

/**
 * @constant {Object&lt;string, string>} LOG_COLORS
 * @description Mapeamento de níveis de log para cores, usado pelo Winston para colorir a saída no console.
 * Facilita a visualização e distinção dos níveis de log durante o desenvolvimento.
 */
const LOG_COLORS = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  verbose: 'cyan',
  debug: 'blue',
  silly: 'grey',
};
winston.addColors(LOG_COLORS);

/**
 * @constant {winston.Logform.Format} consoleFormat
 * @description Formato customizado para logs exibidos no console.
 * Inclui timestamp, colorização, tratamento de `splat` (interpolação de strings),
 * extração de metadados e formatação customizada da string de log.
 * A formatação visa clareza e legibilidade, incluindo informações como serviço, instância e label.
 */
const consoleFormat = winston.format.combine(
  winston.format.timestamp({ format: () => new Date().toISOString() }),
  winston.format.colorize({ all: true }),
  winston.format.splat(),
  winston.format.metadata({
    fillExcept: ['message', 'level', 'timestamp', 'label', 'service', 'instanceId', 'environment', 'stack'],
  }),
  winston.format.printf((info) => {
    const { timestamp, level, message, metadata, stack } = info;
    const label = metadata?.label;
    const labelPart = label ? ` [${label}]` : '';
    const metaToPrint = { ...metadata };
    if (label) {
      delete metaToPrint.label;
    }

    const metaPart = Object.keys(metaToPrint).length > 0 ? ` ${util.inspect(metaToPrint, { colors: true, depth: 2 })}` : '';

    const servicePart = info.service ? ` [${info.service}]` : '';
    const instancePart = info.instanceId ? ` [${info.instanceId}]` : '';

    const stackPart = stack ? `\n${stack}` : '';

    return `[${timestamp}] [${level}]${servicePart}${instancePart}${labelPart} - ${message}${metaPart}${stackPart}`;
  }),
);

/**
 * @constant {winston.Logform.Format} fileFormat
 * @description Formato customizado para logs armazenados em arquivos.
 * Inclui timestamp, tratamento de `splat`, serialização de erros (incluindo stack trace),
 * extração de metadados e formatação final em JSON para fácil parseamento e análise posterior.
 * O JSON é indentado para melhor legibilidade humana quando inspecionado diretamente.
 */
const fileFormat = winston.format.combine(
  winston.format.timestamp(),
  winston.format.splat(),
  winston.format.errors({ stack: true }),
  winston.format.metadata({
    fillExcept: ['message', 'level', 'timestamp', 'service', 'instanceId', 'environment', 'stack'],
  }),
  winston.format.json({
    space: 2,
  }),
);

/**
 * @function getDefaultTransportDefinitions
 * @description Retorna um array com as definições padrão dos transportes do Winston.
 * Estas definições são usadas para criar instâncias de transporte para console e arquivos de log rotacionados.
 * Inclui um transporte para console e três transportes de arquivo: um para todos os logs (nível configurado),
 * um específico para erros e outro específico para avisos.
 *
 * @param {string} level - O nível de log mínimo para o transporte principal da aplicação (console e arquivo geral).
 *                         Os transportes de erro e aviso terão seus níveis fixos ('error' e 'warn', respectivamente).
 * @returns {Array&lt;Object>} Um array de objetos, onde cada objeto representa a definição de um transporte.
 *   Cada definição contém:
 *   - `type`: {string} O tipo de transporte ('console' ou 'dailyRotateFile').
 *   - `options`: {Object} As opções de configuração para o respectivo transporte.
 */
const getDefaultTransportDefinitions = (level) => [
  {
    type: 'console',
    options: {
      level: level,
      format: consoleFormat,
      handleExceptions: true,
      handleRejections: true,
    },
  },
  {
    type: 'dailyRotateFile',
    options: {
      filename: path.join(LOG_DEFAULTS.LOG_DIR, LOG_DEFAULTS.APP_LOG_FILENAME),
      datePattern: LOG_DEFAULTS.DATE_PATTERN,
      zippedArchive: LOG_DEFAULTS.ZIPPED_ARCHIVE,
      maxSize: LOG_DEFAULTS.MAX_SIZE_APP,
      maxFiles: LOG_DEFAULTS.MAX_FILES_APP,
      level: level,
      format: fileFormat,
      mode: LOG_DEFAULTS.FILE_PERMISSIONS,
    },
  },
  {
    type: 'dailyRotateFile',
    options: {
      filename: path.join(LOG_DEFAULTS.LOG_DIR, LOG_DEFAULTS.ERROR_LOG_FILENAME),
      level: 'error',
      datePattern: LOG_DEFAULTS.DATE_PATTERN,
      zippedArchive: LOG_DEFAULTS.ZIPPED_ARCHIVE,
      maxSize: LOG_DEFAULTS.MAX_SIZE_ERROR,
      maxFiles: LOG_DEFAULTS.MAX_FILES_ERROR,
      format: fileFormat,
      mode: LOG_DEFAULTS.FILE_PERMISSIONS,
      handleExceptions: true,
      handleRejections: true,
    },
  },
  {
    type: 'dailyRotateFile',
    options: {
      filename: path.join(LOG_DEFAULTS.LOG_DIR, LOG_DEFAULTS.WARN_LOG_FILENAME),
      level: 'warn',
      datePattern: LOG_DEFAULTS.DATE_PATTERN,
      zippedArchive: LOG_DEFAULTS.ZIPPED_ARCHIVE,
      maxSize: LOG_DEFAULTS.MAX_SIZE_WARN,
      maxFiles: LOG_DEFAULTS.MAX_FILES_WARN,
      format: fileFormat,
      mode: LOG_DEFAULTS.FILE_PERMISSIONS,
    },
  },
];

/**
 * @function ensureLogDirectoryExists
 * @private
 * @description Garante que o diretório de logs, conforme definido em `LOG_DEFAULTS.LOG_DIR`, exista.
 * Se o diretório não existir, ele será criado recursivamente com as permissões especificadas
 * em `LOG_DEFAULTS.DIR_PERMISSIONS`.
 * Emite logs para o console sobre o status da operação.
 *
 * @throws {Error} Se houver falha ao criar o diretório de log ou se não for possível
 *                 garantir acesso de escrita ao diretório. Esta é uma condição crítica
 *                 que impede a configuração correta do logger.
 */
function ensureLogDirectoryExists() {
  const logDir = LOG_DEFAULTS.LOG_DIR;
  const dirMode = LOG_DEFAULTS.DIR_PERMISSIONS;

  try {
    fs.mkdirSync(logDir, { recursive: true, mode: dirMode });

    console.log(`[ LoggerSetup ] Diretório de log garantido: '${logDir}' (modo ${dirMode.toString(8)})`);
  } catch (error) {
    console.error(`\n[ LoggerSetup ] !!! ERRO CRÍTICO !!!`);
    console.error(`Falha ao criar ou garantir acesso de escrita ao diretório de log: '${logDir}'`);
    throw new Error(`Falha na configuração do Logger: Não foi possível acessar/criar o diretório de log '${logDir}'. Erro original: ${error.message}`);
  }
}

/**
 * @function createLoggerInstance
 * @description Cria e configura uma nova instância do logger Winston.
 * Esta função é o núcleo da configuração do sistema de logging.
 *
 * @param {Object} [overrideOptions={}] - Um objeto opcional para sobrescrever as configurações padrão do logger.
 * @param {string} [overrideOptions.level] - Nível de log a ser usado. Se não fornecido, usa `DEFAULT_LOG_LEVEL`.
 * @param {Array&lt;winston.transport>} [overrideOptions.transports] - Um array de transportes Winston já instanciados.
 *                                                                  Se fornecido, ignora `transportDefinitions`.
 * @param {Array&lt;Object>} [overrideOptions.transportDefinitions] - Um array de definições de transporte, similar ao
 *                                                                 retornado por `getDefaultTransportDefinitions`.
 *                                                                 Usado se `overrideOptions.transports` não for fornecido.
 * @param {Object} [overrideOptions.defaultMeta] - Metadados padrão a serem adicionados a todas as mensagens de log
 *                                                 desta instância. Estes são mesclados com os metadados base
 *                                                 (service, instanceId, environment).
 *
 * @returns {winston.Logger} Uma instância configurada do logger Winston.
 *
 * @example
 * // Criar logger com configurações padrão
 * const defaultLogger = createLoggerInstance();
 * defaultLogger.info("Mensagem de log padrão.");
 *
 * // Criar logger com nível 'error' e metadados customizados
 * const errorOnlyLogger = createLoggerInstance({
 *   level: 'error',
 *   defaultMeta: { component: 'payment-gateway' }
 * });
 * errorOnlyLogger.error("Falha crítica no gateway.", { transactionId: '123' });
 *
 * @throws {Error} Propaga erros de `ensureLogDirectoryExists` se o diretório de log não puder ser acessado/criado.
 */
const createLoggerInstance = (overrideOptions = {}) => {
  ensureLogDirectoryExists();

  const effectiveLevel = overrideOptions.level || DEFAULT_LOG_LEVEL;

  let configuredTransports;
  if (overrideOptions.transports) {
    configuredTransports = overrideOptions.transports;
  } else {
    const transportDefinitions = overrideOptions.transportDefinitions || getDefaultTransportDefinitions(effectiveLevel);
    configuredTransports = transportDefinitions
      .map((def) => {
        try {
          switch (def.type) {
            case 'console':
              return new winston.transports.Console(def.options);
            case 'dailyRotateFile':
              return new DailyRotateFile(def.options);
            default:
              console.warn(`[ LoggerSetup ] Tipo de transporte desconhecido: ${def.type}. Pulando.`);
              return null;
          }
        } catch (error) {
          console.error(`[ LoggerSetup ] Falha ao criar transporte tipo ${def.type}: ${error.message}`, error);
          return null;
        }
      })
      .filter(Boolean);
  }

  const baseDefaultMeta = {
    service: ECOSYSTEM_NAME,
    instanceId: INSTANCE_ID,
    environment: NODE_ENV,
  };

  const defaultMeta = {
    ...baseDefaultMeta,
    ...(overrideOptions.defaultMeta || {}),
  };

  const loggerInstance = winston.createLogger({
    level: effectiveLevel,
    levels: LOG_LEVELS,
    format: winston.format.combine(winston.format.errors({ stack: true })),
    defaultMeta: defaultMeta,
    transports: configuredTransports,
    exitOnError: false,
  });

  loggerInstance.on('error', (error) => {
    console.error('Erro ocorrido dentro do Winston Logger:', error);
  });

  console.log(`[ LoggerSetup ] Instância do Logger criada. Nível: ${effectiveLevel}, Env: ${NODE_ENV}, Instância: ${INSTANCE_ID}, Serviço: ${ECOSYSTEM_NAME}`);

  return loggerInstance;
};

/**
 * @constant {winston.Logger} logger
 * @description Instância principal do logger Winston, configurada com as definições padrão.
 * Este é o logger exportado e deve ser usado em toda a aplicação para registrar mensagens.
 * Ele é inicializado chamando `createLoggerInstance()` sem argumentos,
 * utilizando assim as configurações derivadas das variáveis de ambiente e dos `LOG_DEFAULTS`.
 *
 * @example
 * const logger = require('./logger'); // Supondo que este arquivo seja logger.js
 * logger.info('Aplicação iniciada com sucesso.', { port: 3000 });
 * logger.error('Falha ao conectar ao banco de dados.', { error: new Error('DB Timeout') });
 */
const logger = createLoggerInstance();

module.exports = logger;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ConnectionManager.html">ConnectionManager</a></li><li><a href="MySQLDBManager.html">MySQLDBManager</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DEFAULT_LOG_LEVEL">DEFAULT_LOG_LEVEL</a></li><li><a href="global.html#ECOSYSTEM_NAME">ECOSYSTEM_NAME</a></li><li><a href="global.html#INSTANCE_ID">INSTANCE_ID</a></li><li><a href="global.html#IS_PRODUCTION">IS_PRODUCTION</a></li><li><a href="global.html#LOG_COLORS">LOG_COLORS</a></li><li><a href="global.html#LOG_DEFAULTS">LOG_DEFAULTS</a></li><li><a href="global.html#LOG_DIR_PATH">LOG_DIR_PATH</a></li><li><a href="global.html#LOG_LEVELS">LOG_LEVELS</a></li><li><a href="global.html#LOG_LEVEL_NAMES">LOG_LEVEL_NAMES</a></li><li><a href="global.html#NODE_ENV">NODE_ENV</a></li><li><a href="global.html#PROJECT_ROOT">PROJECT_ROOT</a></li><li><a href="global.html#REDIS_PREFIX_CHAT">REDIS_PREFIX_CHAT</a></li><li><a href="global.html#REDIS_PREFIX_CONTACT">REDIS_PREFIX_CONTACT</a></li><li><a href="global.html#REDIS_PREFIX_GROUP">REDIS_PREFIX_GROUP</a></li><li><a href="global.html#REDIS_PREFIX_MESSAGE">REDIS_PREFIX_MESSAGE</a></li><li><a href="global.html#REDIS_TTL_MESSAGE">REDIS_TTL_MESSAGE</a></li><li><a href="global.html#REDIS_TTL_METADATA_LONG">REDIS_TTL_METADATA_LONG</a></li><li><a href="global.html#REDIS_TTL_METADATA_SHORT">REDIS_TTL_METADATA_SHORT</a></li><li><a href="global.html#REDIS_TTL_RECEIPT">REDIS_TTL_RECEIPT</a></li><li><a href="global.html#_extractTextFromMessageObject">_extractTextFromMessageObject</a></li><li><a href="global.html#closePool">closePool</a></li><li><a href="global.html#connectConecta-seaoWhatsAppusandooestadodeautentica%25C3%25A7%25C3%25A3ocarregado.ConfiguraosocketBaileyscomasop%25C3%25A7%25C3%25B5esnecess%25C3%25A1rias,incluindologger,informa%25C3%25A7%25C3%25B5esdonavegador,eafun%25C3%25A7%25C3%25A3o%2560cachedGroupMetadata%2560paraotimizarocarregamentodemetadadosdegrupoapartirdoRedis.">connect
Conecta-se ao WhatsApp usando o estado de autenticação carregado.
Configura o socket Baileys com as opções necessárias, incluindo logger, informações do navegador, e a função `cachedGroupMetadata` para otimizar o carregamento de metadados de grupo a partir do Redis.</a></li><li><a href="global.html#consoleFormat">consoleFormat</a></li><li><a href="global.html#createLoggerInstance">createLoggerInstance</a></li><li><a href="global.html#deleteChatData">deleteChatData</a></li><li><a href="global.html#env">env</a></li><li><a href="global.html#executeQuery">executeQuery</a></li><li><a href="global.html#fileFormat">fileFormat</a></li><li><a href="global.html#getDefaultTransportDefinitions">getDefaultTransportDefinitions</a></li><li><a href="global.html#getEventEmitter">getEventEmitter</a></li><li><a href="global.html#getInstance">getInstance</a></li><li><a href="global.html#handleBlocklistSetProcessaoeventodedefini%25C3%25A7%25C3%25A3odalistadebloqueio.Registraosn%25C3%25BAmerosqueest%25C3%25A3onalistadebloqueiodoWhatsApp.Esteevento%25C3%25A9disparadoquandoalistadebloqueio%25C3%25A9definidaousincronizada(evento'blocklist.set').">handleBlocklistSet
Processa o evento de definição da lista de bloqueio.
Registra os números que estão na lista de bloqueio do WhatsApp.
Este evento é disparado quando a lista de bloqueio é definida ou sincronizada (evento 'blocklist.set').</a></li><li><a href="global.html#handleBlocklistUpdateProcessaatualiza%25C3%25A7%25C3%25B5esnalistadebloqueiodoWhatsApp.Registraaltera%25C3%25A7%25C3%25B5es(adi%25C3%25A7%25C3%25B5es/remo%25C3%25A7%25C3%25B5es)nalistadecontatosbloqueados.Esteevento%25C3%25A9disparadoquandoumJID%25C3%25A9adicionadoouremovidodalistadebloqueio(evento'blocklist.update').">handleBlocklistUpdate
Processa atualizações na lista de bloqueio do WhatsApp.
Registra alterações (adições/remoções) na lista de contatos bloqueados.
Este evento é disparado quando um JID é adicionado ou removido da lista de bloqueio (evento 'blocklist.update').</a></li><li><a href="global.html#handleCallProcessaeventosdechamadasrecebidasourealizadas.Registrainforma%25C3%25A7%25C3%25B5essobrechamadasdevoz/v%25C3%25ADdeonoWhatsApp.Esteevento%25C3%25A9disparadoparav%25C3%25A1riosest%25C3%25A1giosdeumachamada(oferta,aceita%25C3%25A7%25C3%25A3o,rejei%25C3%25A7%25C3%25A3o,t%25C3%25A9rmino)(evento'call').">handleCall
Processa eventos de chamadas recebidas ou realizadas.
Registra informações sobre chamadas de voz/vídeo no WhatsApp.
Este evento é disparado para vários estágios de uma chamada (oferta, aceitação, rejeição, término) (evento 'call').</a></li><li><a href="global.html#handleChatsDeleteManipulaexclus%25C3%25A3odechats.Esteevento%25C3%25A9disparadoquandochatss%25C3%25A3odeletados(evento'chats.delete').">handleChatsDelete
Manipula exclusão de chats.
Este evento é disparado quando chats são deletados (evento 'chats.delete').</a></li><li><a href="global.html#handleChatsUpdateManipulaatualiza%25C3%25A7%25C3%25B5esdechats.Esteevento%25C3%25A9disparadoquandopropriedadesdeumchatexistentes%25C3%25A3oalteradas(ex:%2560unreadCount%2560,%2560mute%2560)(evento'chats.update').">handleChatsUpdate
Manipula atualizações de chats.
Este evento é disparado quando propriedades de um chat existente são alteradas (ex: `unreadCount`, `mute`) (evento 'chats.update').</a></li><li><a href="global.html#handleChatsUpsertManipulainser%25C3%25A7%25C3%25A3o/atualiza%25C3%25A7%25C3%25A3odechats.Esteevento%25C3%25A9disparadoquandonovoschatss%25C3%25A3ocriadosouchatsexistentess%25C3%25A3osincronizados(evento'chats.upsert').">handleChatsUpsert
Manipula inserção/atualização de chats.
Este evento é disparado quando novos chats são criados ou chats existentes são sincronizados (evento 'chats.upsert').</a></li><li><a href="global.html#handleConnectionUpdateManipulaatualiza%25C3%25A7%25C3%25B5esdeconex%25C3%25A3odoclienteWhatsApp.Estem%25C3%25A9todo%25C3%25A9chamadoquandooestadodaconex%25C3%25A3ocomoWhatsAppmuda(evento%2560connection.update%2560).">handleConnectionUpdate
Manipula atualizações de conexão do cliente WhatsApp.
Este método é chamado quando o estado da conexão com o WhatsApp muda (evento `connection.update`).</a></li><li><a href="global.html#handleContactsUpdateManipulaaatualiza%25C3%25A7%25C3%25A3odecontatosnosistema.Respons%25C3%25A1velporatualizarasinforma%25C3%25A7%25C3%25B5esdecontatonocacheRedis.Esteevento%25C3%25A9disparadoquandopropriedadesdeumcontatoexistentes%25C3%25A3oalteradas(ex:nome,notifica%25C3%25A7%25C3%25A3opush)(evento'contacts.update').">handleContactsUpdate
Manipula a atualização de contatos no sistema.
Responsável por atualizar as informações de contato no cache Redis.
Este evento é disparado quando propriedades de um contato existente são alteradas (ex: nome, notificação push) (evento 'contacts.update').</a></li><li><a href="global.html#handleContactsUpsertManipulainser%25C3%25A7%25C3%25A3o/atualiza%25C3%25A7%25C3%25A3odecontatos.Esteevento%25C3%25A9disparadoquandonovoscontatoss%25C3%25A3oadicionadosoucontatosexistentess%25C3%25A3osincronizados(evento'contacts.upsert').">handleContactsUpsert
Manipula inserção/atualização de contatos.
Este evento é disparado quando novos contatos são adicionados ou contatos existentes são sincronizados (evento 'contacts.upsert').</a></li><li><a href="global.html#handleCredsUpdateManipulaaatualiza%25C3%25A7%25C3%25A3odecredenciais.Estem%25C3%25A9todo%25C3%25A9chamadoporBaileysquandoascredenciaisdeautentica%25C3%25A7%25C3%25A3os%25C3%25A3oatualizadas(porexemplo,ap%25C3%25B3sescanearoQRcodeouduranteareconex%25C3%25A3o).Salvaasnovascredenciaisusando%2560this.auth.saveCreds()%2560.">handleCredsUpdate
Manipula a atualização de credenciais.
Este método é chamado por Baileys quando as credenciais de autenticação são atualizadas (por exemplo, após escanear o QR code ou durante a reconexão).
Salva as novas credenciais usando `this.auth.saveCreds()`.</a></li><li><a href="global.html#handleGroupParticipantsUpdateManipulaatualiza%25C3%25A7%25C3%25B5esdeparticipantesdegrupos.Chamadoquandoparticipantesentram,saem,s%25C3%25A3opromovidosourebaixadosemumgrupo(evento'group-participants.update').">handleGroupParticipantsUpdate
Manipula atualizações de participantes de grupos.
Chamado quando participantes entram, saem, são promovidos ou rebaixados em um grupo (evento 'group-participants.update').</a></li><li><a href="global.html#handleGroupsUpdateManipulaatualiza%25C3%25A7%25C3%25B5esdegrupos.Estem%25C3%25A9todo%25C3%25A9chamadoquandoh%25C3%25A1atualiza%25C3%25A7%25C3%25B5esnosmetadadosdegruposexistentes(ex:mudan%25C3%25A7adenome,descri%25C3%25A7%25C3%25A3o)(evento'groups.update').">handleGroupsUpdate
Manipula atualizações de grupos.
Este método é chamado quando há atualizações nos metadados de grupos existentes (ex: mudança de nome, descrição) (evento 'groups.update').</a></li><li><a href="global.html#handleGroupsUpsertManipulaainser%25C3%25A7%25C3%25A3o/atualiza%25C3%25A7%25C3%25A3odegrupos(quandoousu%25C3%25A1rioentraemumnovogrupoousincroniza%25C3%25A7%25C3%25A3oinicial).Esteevento%25C3%25A9geralmentedisparadoquandooclienteseconectaesincronizaalistadegrupos,ouquandoousu%25C3%25A1rioentraemumnovogrupo(evento'groups.upsert').">handleGroupsUpsert
Manipula a inserção/atualização de grupos (quando o usuário entra em um novo grupo ou sincronização inicial).
Este evento é geralmente disparado quando o cliente se conecta e sincroniza a lista de grupos,
ou quando o usuário entra em um novo grupo (evento 'groups.upsert').</a></li><li><a href="global.html#handleIrrecoverableDisconnectManipuladesconex%25C3%25A3oirrecuper%25C3%25A1vel(ex:logoutoum%25C3%25A1ximodetentativasatingido).Registraumerroinformandoousu%25C3%25A1riosobreasitua%25C3%25A7%25C3%25A3oeanecessidadederemoverosdadosdeautentica%25C3%25A7%25C3%25A3oereiniciarparagerarumnovoQRcode.Resetaoestadodereconex%25C3%25A3o.">handleIrrecoverableDisconnect
Manipula desconexão irrecuperável (ex: logout ou máximo de tentativas atingido).
Registra um erro informando o usuário sobre a situação e a necessidade de
remover os dados de autenticação e reiniciar para gerar um novo QR code.
Reseta o estado de reconexão.</a></li><li><a href="global.html#handleMessageReceiptUpdateManipulaatualiza%25C3%25A7%25C3%25B5esderecibodemensagem.Esteevento%25C3%25A9disparadoquandoostatusdeentrega/leituradeumamensagem%25C3%25A9atualizado(ex:'delivered','read','played')(evento'message-receipt.update').">handleMessageReceiptUpdate
Manipula atualizações de recibo de mensagem.
Este evento é disparado quando o status de entrega/leitura de uma mensagem é atualizado
(ex: 'delivered', 'read', 'played') (evento 'message-receipt.update').</a></li><li><a href="global.html#handleMessagesDeleteManipulaexclus%25C3%25A3odemensagens.Esteevento%25C3%25A9disparadoquandomensagenss%25C3%25A3odeletadas(evento'messages.delete').">handleMessagesDelete
Manipula exclusão de mensagens.
Este evento é disparado quando mensagens são deletadas (evento 'messages.delete').</a></li><li><a href="global.html#handleMessagesReactionManipularea%25C3%25A7%25C3%25B5esamensagens.Esteevento%25C3%25A9disparadoquandoumarea%25C3%25A7%25C3%25A3o%25C3%25A9adicionadaouremovidadeumamensagem(evento'messages.reaction').">handleMessagesReaction
Manipula reações a mensagens.
Este evento é disparado quando uma reação é adicionada ou removida de uma mensagem (evento 'messages.reaction').</a></li><li><a href="global.html#handleMessagesUpdateManipulaatualiza%25C3%25A7%25C3%25B5esdemensagens.Esteevento%25C3%25A9disparadoparaatualiza%25C3%25A7%25C3%25B5esemmensagensexistentes(ex:statusdeentrega,edi%25C3%25A7%25C3%25A3o-sesuportado)(evento'messages.update').">handleMessagesUpdate
Manipula atualizações de mensagens.
Este evento é disparado para atualizações em mensagens existentes (ex: status de entrega, edição - se suportado) (evento 'messages.update').</a></li><li><a href="global.html#handleMessagesUpsertManipulamensagensnovas/atualizadas.Estem%25C3%25A9todo%25C3%25A9chamadoquandonovasmensagenss%25C3%25A3orecebidasoumensagensexistentess%25C3%25A3oatualizadas(evento'messages.upsert').">handleMessagesUpsert
Manipula mensagens novas/atualizadas.
Este método é chamado quando novas mensagens são recebidas ou mensagens existentes são atualizadas (evento 'messages.upsert').</a></li><li><a href="global.html#handleMessagingHistorySetManipulaoeventodeconjuntodehist%25C3%25B3ricodemensagens.Esteevento%25C3%25A9disparadoduranteasincroniza%25C3%25A7%25C3%25A3oinicialdohist%25C3%25B3rico(evento'messaging-history.set'),fornecendoumconjuntodechats,contatosemensagens.">handleMessagingHistorySet
Manipula o evento de conjunto de histórico de mensagens.
Este evento é disparado durante a sincronização inicial do histórico (evento 'messaging-history.set'),
fornecendo um conjunto de chats, contatos e mensagens.</a></li><li><a href="global.html#handlePresenceUpdateProcessaatualiza%25C3%25A7%25C3%25B5esdepresen%25C3%25A7adoscontatos.Registraemonitoraaltera%25C3%25A7%25C3%25B5esnostatusdepresen%25C3%25A7a(online,offline,digitando,gravando%25C3%25A1udio)e%25C3%25BAltimavisualiza%25C3%25A7%25C3%25A3o(evento'presence.update').">handlePresenceUpdate
Processa atualizações de presença dos contatos.
Registra e monitora alterações no status de presença (online, offline, digitando, gravando áudio) e última visualização (evento 'presence.update').</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeInicializaaconex%25C3%25A3oprincipalcomoWhatsApp.Estem%25C3%25A9todoorquestraocarregamentodoestadodeautentica%25C3%25A7%25C3%25A3oe,emseguida,tentaestabeleceraconex%25C3%25A3ocomoWhatsApp.">initialize
Inicializa a conexão principal com o WhatsApp.
Este método orquestra o carregamento do estado de autenticação e, em seguida,
tenta estabelecer a conexão com o WhatsApp.</a></li><li><a href="global.html#initializeRedisClientInicializaoclienteRedisparacachededados.Configuraconex%25C3%25A3o,eventosetratamentodeerrosdoRedis.Osdetalhesdaconex%25C3%25A3o(host,porta,senha,db)s%25C3%25A3oobtidosdasvari%25C3%25A1veisdeambiente.Registralistenersparaoseventos'connect','ready'e'error'doclienteRedis.">initializeRedisClient
Inicializa o cliente Redis para cache de dados.
Configura conexão, eventos e tratamento de erros do Redis.
Os detalhes da conexão (host, porta, senha, db) são obtidos das variáveis de ambiente.
Registra listeners para os eventos 'connect', 'ready' e 'error' do cliente Redis.</a></li><li><a href="global.html#loadAuthStateCarregaoestadodeautentica%25C3%25A7%25C3%25A3ododiret%25C3%25B3rioespecificadoem%2560this.authStatePath%2560.Seodiret%25C3%25B3rion%25C3%25A3oexistir,eleser%25C3%25A1criado.Utiliza%2560useMultiFileAuthState%2560dabibliotecaBaileysparagerenciarascredenciais.">loadAuthState
Carrega o estado de autenticação do diretório especificado em `this.authStatePath`.
Se o diretório não existir, ele será criado.
Utiliza `useMultiFileAuthState` da biblioteca Baileys para gerenciar as credenciais.</a></li><li><a href="global.html#logger">logger</a></li><li><a href="global.html#processIncomingMessage">processIncomingMessage</a></li><li><a href="global.html#reconnectWithBackoffReconectaaoWhatsAppcombackoffexponencial.Incrementaocontadordetentativasdereconex%25C3%25A3oecalculaopr%25C3%25B3ximoatrasodeformaexponencial,limitadopelo%2560maxBackoffDelayMs%2560.Agendaumanovatentativadeconex%25C3%25A3o(%2560this.connect()%2560)ap%25C3%25B3soatrasocalculado.Seareconex%25C3%25A3ofalhar,eaindaforpermitidotentarnovamente,chamaasimesmorecursivamente.Casocontr%25C3%25A1rio,tratacomodesconex%25C3%25A3oirrecuper%25C3%25A1vel.">reconnectWithBackoff
Reconecta ao WhatsApp com backoff exponencial.
Incrementa o contador de tentativas de reconexão e calcula o próximo atraso
de forma exponencial, limitado pelo `maxBackoffDelayMs`.
Agenda uma nova tentativa de conexão (`this.connect()`) após o atraso calculado.
Se a reconexão falhar, e ainda for permitido tentar novamente, chama a si mesmo recursivamente. Caso contrário, trata como desconexão irrecuperável.</a></li><li><a href="global.html#resetReconnectionStateResetaoestadodereconex%25C3%25A3o.Define%2560this.reconnectionAttempts%2560para0,%2560this.currentBackoffDelayMs%2560para%2560this.initialBackoffDelayMs%2560,e%2560this.isReconnecting%2560para%2560false%2560.">resetReconnectionState
Reseta o estado de reconexão.
Define `this.reconnectionAttempts` para 0, `this.currentBackoffDelayMs` para `this.initialBackoffDelayMs`,
e `this.isReconnecting` para `false`.</a></li><li><a href="global.html#setupEventHandlersConfiguraosmanipuladoresdeeventosparaoclienteWhatsApp(Baileys).Registralistenersparaumavariedadedeeventos,comoatualiza%25C3%25A7%25C3%25B5esdeconex%25C3%25A3o,recebimentodemensagens,atualiza%25C3%25A7%25C3%25B5esdegrupos,chats,contatos,etc.Cadaevento%25C3%25A9vinculadoaom%25C3%25A9todocorrespondentenestaclasse.">setupEventHandlers
Configura os manipuladores de eventos para o cliente WhatsApp (Baileys).
Registra listeners para uma variedade de eventos, como atualizações de conexão,
recebimento de mensagens, atualizações de grupos, chats, contatos, etc.
Cada evento é vinculado ao método correspondente nesta classe.</a></li><li><a href="global.html#shouldReconnectDeterminaseareconex%25C3%25A3odevesertentadacombasenomotivodadesconex%25C3%25A3o.">shouldReconnect
Determina se a reconexão deve ser tentada com base no motivo da desconexão.</a></li><li><a href="global.html#start">start</a></li><li><a href="global.html#syncFromRedis">syncFromRedis</a></li><li><a href="global.html#updateGroupParticipants">updateGroupParticipants</a></li><li><a href="global.html#upsertChat">upsertChat</a></li><li><a href="global.html#upsertGroup">upsertGroup</a></li><li><a href="global.html#upsertMessage">upsertMessage</a></li><li><a href="global.html#upsertMessageReceipt">upsertMessageReceipt</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun May 25 2025 17:52:33 GMT-0400 (Horário Padrão do Amazonas)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
